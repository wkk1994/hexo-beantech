---
title: Linux之文件系统
date: 2020-09-10 13:36:30
catalog: true
subtitle: "文件系统"
header-img: "/images/default-head6.jpg"
tags:
- Linux
- 文件系统
- 日志型文件系统
- 页缓存
catagories:
- Linux相关笔记
---


# Linux之文件系统

![文件系统概览](https://static001.geekbang.org/resource/image/3c/73/3c506edf93b15341da3db658e9970773.jpg)

在Linux中一切皆文件，不仅是普通的文件和目录，就连块设备、套接字、管道等，也都要通过统一的的文件系统管理。

## VFS（虚拟文件系统）

为了支持不同的文件系统，Linux内核在用户进程和文件系统之间，引入VFS。VFS定义了一组所有文件系统都支持的数据结构和标准接口。这样，用户进程和内核中的其他子系统，只需要跟VFS提供的统一接口就可以进行交互。

## 文件系统

文件系统需要挂载到VFS才能使用和访问。常见的文件系统有Ext4、XFS等。

Linux 文件系统的四大基本要素：目录项、索引节点、逻辑块以及超级块。

![文件系统关系](https://static001.geekbang.org/resource/image/32/47/328d942a38230a973f11bae67307be47.png)

### 超级块（Super Block）

表示一个文件系统。存储一个已安装的文件的控制信息，包括文件系统的名称（如Ext4）、文件系统的大小和状态、块设备的引用和元数据信息（比如空闲列表等等）。超级块和磁盘上文件系统的超级块对应。

### 目录项（Dentry）

用来记录文件的名称、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。目录项是由内核维护的一个内存数据结构，所以通常也被叫做目录项缓存。

### 索引节点（Inode）

记录了文件相关的元数据信息，比如Inode 编号、文件大小、访问权限、修改日期、数据的位置等。索引节点和文件一一对应，它跟文件内容一样都会被持久化存储到磁盘中。

Inode分为两种：一种是VFS的Inode，一种是具体文件系统的Inode。前者在内存中，后者在磁盘中。所以每次其实是将磁盘中的Inode调进填充内存中的Inode，这样才是算使用了磁盘文件Inode。当创建一个文件的时候，就给文件分配了一个Inode。一个Inode只对应一个实际文件，一个文件也会只有一个Inode（Unix/Linux系统中目录也是一种文件，打开目录实际上就是打开目录文件。目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码）。

### 逻辑块

磁盘读写的最小单位是扇区，一个扇区的大小是512B，如果每次读写这么小的单位效率很低。所以，文件系统又把连续的扇区组成了逻辑块（Block），然后每次都以逻辑块做为最小单位，来管理数据。常见的逻辑块大小是4KB。在格式化的时候，这个值是可以设定的。

### 页缓冲（Page Cache）

每次访问数据都要从磁盘中获取，这样势必很慢。所以Linux在文件系统中添加了页缓冲。通过将磁盘中的数据缓存到内存中，从而减少磁盘的IO操作，从而提高性能。一个inode对应一个page cache对象，一个page cache对象包含多个物理page。

当内核发起一个读请求时，首先会检查请求的数据是否缓存到了page cache中，如果有，那么直接从内存中获取，不需要访问磁盘，这个称为cache命中（cache hit）。如果cache中没有请求的数据，即cache未命中（cache miss），就要从磁盘中读取数据，然后再缓存到page cache中。page可以只缓存一个文件部分的内容，不需要把整个文件都缓存进来。

当内核发起一个写请求时，同样是直接往cache中写入，此时不会立即同步到磁盘中，而是将写入的page设置为脏页。这里有一个问题，数据很危险，一旦宕机就没有了，所以需要一种机制，将写入的页面真正写到硬盘中，称为回写（Write Back）。回写脏页由内核后台线程进行，会检查脏页是否超过指定限制，超过会回写。

触发脏页回写到磁盘时机如下：

* 用户进程主动调用sync()和fsync()系统调用；
* 空闲内存小于特定的阀值；
* 脏数据在内存中驻留的时间超过一个特定的阀值。

### 日志型文件系统

日志型文件系统可以在系统发生断电或者其它系统故障时保证整体数据的完整性。常见的日志文件系统：Ext4、ReiserFS、XFS和JFS。

所谓日志型文件系统，是在传统文件系统的基础上，加入文件系统更改的日志记录。它的设计思想是：跟踪记录文件系统的变化，并将变化内容记录入日志。日志文件系统在磁盘分区中保存有日志记录，写操作首先是对记录文件进行操作，若整个写操作由于某种原因（如系统掉电）而中断，系统重启时，会根据日志记录来恢复中断前的写操作。在日志文件系统中，所有的文件系统的变化都被记录到日志，每隔一定时间，文件系统会将更新后的元数据及文件内容写入磁盘。在对元数据做任何改变以前，文件系统驱动程序会向日志中写入一个条目，这个条目描述了它将要做些什么，然后它修改元数据。

#### Ext4的日志模式

ext4 是一种日志文件系统，日志文件系统比非日志文件系统多了一个 Journal 区域。文件在 ext4 中分两部分存储，一部分是文件的元数据，另一部分是数据。元数据和数据的操作日志 Journal 也是分开管理的。ext4提供以下三种日志模式：

* Journal模式：在将数据写入文件系统前，必需等待元数据和数据的日志已经落盘才能发挥作用。这样做的性能比较差，但是最安全。

* order 模式：不记录数据的日志，只记录元数据的日志，但是在写元数据日志前，必需先确保数据已经落盘。这个折中，是默认模式。

* writeback模式：不记录数据日志，仅记录元数据日志，并且不保证数据比元数据先落盘。这个性能最好，但是不安全。

日志模式可以在挂载ext4的时候选择。

#### inode 与块的存储

inode结构信息中通过属性`__le32 i_block[EXT4_N_BLOCKS]`保存文件的数据信息（指向块的地址）。不同的文件系统实现细节不同。[具体参考](https://time.geekbang.org/column/article/98440)

## 通用块层

通用块层是处在文件系统和磁盘驱动中间的一个块设备抽象层。

和VFS类似，为了减少不同块设备的差异带来的影响，Linux通过一个统一的通用块层，来管理各种不同的块设备。主要功能有两个：

* 和VFS类似，向上，为文件系统和应用程序，提供访问块设备的标准接口；向下，把各种异构的磁盘设备抽象为统一的块设备，并提供统一框架来管理这些设备的驱动程序。

* 给文件系统和应用程序发来的IO请求排序，并通过重新排序，合并请求等方式，提高磁盘读写的效率。

## 设备层

设备层，包括存储设备和相应的驱动程序，负责最终物理设备的 I/O 操作。

## 文件系统 I/O

将文件系统挂载到挂载点后，就可以通过VFS提供的一组标准的文件访问接口访问文件了。文件的读写方式的各种差异，导致IO的分类多种多样。最常见的有，缓冲与非缓冲IO、直接IO与非直接IO、阻塞与非阻塞IO、同步与异步IO等。

* 按照是否使用标准库缓冲分类
  * 缓冲IO：利用标准库缓冲加速文件访问，而标准库内部再通过系统调度访问文件。
  * 非缓冲IO：直接通过系统调用来访问文件，不再经过标准库缓存。

无论缓冲 I/O 还是非缓冲 I/O，它们最终还是要经过系统调用来访问文件。系统调用后，还会通过页缓存，来减少磁盘的 I/O 操作。

* 按照是否利用操作系统的页缓存分类
  * 直接IO：跳过操作系统的页缓存，直接跟文件系统交互来访问文件。
  * 非直接IO：文件读写时，先经过操作系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘。

在系统调用中，指定O_DIRECT标志，表示直接IO，不指定默认非直接IO。

* 根据是否阻塞分类
  * 阻塞IO：是指应用程序执行IO操作后，如果没有获得响应，就会阻塞当前线程。
  * 非阻塞IO：是指应用程序执行IO操作后，不会阻塞当前线程，可以继续执行其他的任务，随后再通过轮询或者事件通知的形式，获取调用的结果。

设置 O_NONBLOCK 标志，就表示用非阻塞方式访问；而如果不做任何设置，默认的就是阻塞访问。例如在访问管道或者网络套接字时，设置 O_NONBLOCK 标志。

* 根据是否等待响应结果分类
  * 同步IO：是指应用程序执行 I/O 操作后，要一直等到整个 I/O 完成后，才能获得 I/O 响应。
  * 异步IO：是指应用程序执行 I/O 操作后，不用等待完成和完成后的响应，而是继续执行就可以。等到这次 I/O 完成后，响应会用事件通知的方式，告诉应用程序。

在系统调用中，指定O_DSYNC或者O_SYNC标志，就代表同步IO。如果设置了 O_DSYNC，就要等文件数据写入磁盘后，才能返回；而 O_SYNC，则是在 O_DSYNC 基础上，要求文件元数据也要写入磁盘后，才能返回。

## 相关命令

```text
# 查看文件节点的编号
$ ls -i
415794 altair.dmp   415793 Dash.zip

# 查看磁盘使用情况
$ df -h /dev/sda1
Filesystem      Size  Used Avail Use% Mounted on
udev            976M     0  976M   0% /dev

# 查看索引节点的使用情况
$ df -i /dev/sda1
Filesystem     Inodes IUsed  IFree IUse% Mounted on
udev           249737   400 249337    1% /dev
```

* [free命令参考](https://cloud.tencent.com/developer/article/1328466)

## 其他知识点

* 在进行文件IO的时候，会涉及到用户态到内核态的复制。
